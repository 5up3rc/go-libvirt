/*
 * This file generated by internal/lvgen/generate.go. DO NOT EDIT BY HAND!
 *
 * To regenerate, run 'go generate' in internal/lvgen.
 */

package libvirt

import (
	"bytes"
	"fmt"

	"github.com/davecgh/go-xdr/xdr2"
	"github.com/digitalocean/go-libvirt/internal/constants"
)

const (
	VirUUIDBuflen = 16
)

// Typedefs:
{{range .Typedefs}}type {{.Name}} {{.Type}}
{{end}}
// Enums:
{{range .Enums}}type {{.Name}} {{.Type}}
{{end}}
// Structs:
{{range .Structs}}type {{.Name}} struct {
{{range .Members}}	{{.Name}} {{.Type}}
{{end -}}
}

{{end}}
// Unions:
{{range .Unions}}type {{.Name}} interface {
	Get() interface{}
{{end -}}
}

{{range .Unions}}{{$uname := .Name}}{{range .Cases}}{{$casetype := printf "%v%v" $uname .CaseName}}
type {{$casetype}} struct {
	DVal uint32
	{{.Name}} {{.Type}}
}
func New{{$casetype}}(v {{.Type}}) *{{$casetype}} { return &{{$casetype}}{DVal: {{.DiscriminantVal}}, {{.Name}}: v} }
func Decode{{$casetype}}(dec *xdr.Decoder) (*{{$casetype}}, error) {
	var v {{.Type}}
	_, err := dec.Decode(&v)
	if err != nil {
		return nil, err
	}
	return New{{$casetype}}(v), nil
}
func (c *{{$casetype}}) Get() interface{} { return c.{{.Name}} }
{{end}}
{{- end}}

// TODO: Generate this.
func decodeTypedParams(dec *xdr.Decoder) ([]TypedParam, error) {
	count, _, err := dec.DecodeInt()
	params := make([]TypedParam, count)
	if err != nil {
		return nil, err
	}
	for ix := int32(0); ix < count; ix++ {
		name, _, err := dec.DecodeString()
		if err != nil {
			return nil, err
		}
		ptype, _, err := dec.DecodeInt()
		if err != nil {
			return nil, err
		}
		var tpv TypedParamValue
		switch ptype {
		case 1:	// TypedParamValueInt
			tpv, err = DecodeTypedParamValueInt(dec)
		case 2: // TypedParamValueUint
			tpv, err = DecodeTypedParamValueUint(dec)
		case 3: // TypedParamValueLlong
			tpv, err = DecodeTypedParamValueLlong(dec)
		case 4: // TypedParamValueUllong
			tpv, err = DecodeTypedParamValueUllong(dec)
		case 5: // TypedParamValueDouble
			tpv, err = DecodeTypedParamValueDouble(dec)
		case 6: // TypedParamValueBoolean
			tpv, err = DecodeTypedParamValueBoolean(dec)
		case 7: // TypedParamValueString
			tpv, err = DecodeTypedParamValueString(dec)
		default:
			err = fmt.Errorf("invalid parameter type %v", ptype)
		}

		if err != nil {
			return nil, err
		}

		params[ix] = TypedParam{name, tpv}
	}

	return params, nil
}

// Procedures:
{{range .Procs}}
func (l *Libvirt) {{.Name}}({{range $ix, $arg := .Args}}{{if $ix}}, {{end}}{{.Name}} {{.Type}}{{end}}) ({{range .Ret}}r{{.Name}} {{.Type}}, {{end}}err error) {
	var buf bytes.Buffer
{{if .ArgsStruct}}
	args := {{.ArgsStruct}} {
{{range .Args}}		{{.Name}}: {{.Name}},
{{end}}	}

	buf, err = encode(&args)
	if err != nil {
		return
	}
{{end}}
	var resp <-chan response
	resp, err = l.request({{.Num}}, constants.Program, &buf)
	if err != nil {
		return
	}

	r := <-resp
	if r.Status != StatusOK {
		err = decodeError(r.Payload)
		return
	}
{{if .RetStruct}}
	// Return value unmarshaling
	rdr := bytes.NewReader(r.Payload)
	dec := xdr.NewDecoder(rdr)
{{range .Ret}}	// {{.Name}}: {{.Type}}
{{if eq .Type "[]TypedParam"}}	// {{.Name}}
	r{{.Name}}, err = decodeTypedParams(dec)
	if err != nil {
		return
	}
{{else}}	_, err = dec.Decode(&r{{.Name}})
	if err != nil {
		return
	}
{{end}}{{end}}
{{end}}
	return
}
{{end}}
